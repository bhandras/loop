// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: batch.sql

package sqlc

import (
	"context"
	"database/sql"
)

const cancelBatch = `-- name: CancelBatch :exec
UPDATE sweep_batches SET
        cancelled = TRUE
WHERE id = $1
`

func (q *Queries) CancelBatch(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, cancelBatch, id)
	return err
}

const confirmBatch = `-- name: ConfirmBatch :exec
UPDATE
        sweep_batches
SET
        confirmed = TRUE
WHERE
        id = $1
`

func (q *Queries) ConfirmBatch(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, confirmBatch, id)
	return err
}

const getBatchSweeps = `-- name: GetBatchSweeps :many
SELECT
        id, swap_hash, batch_id, outpoint, amt, completed
FROM
        sweeps
WHERE
        batch_id = $1
ORDER BY
        id ASC
`

func (q *Queries) GetBatchSweeps(ctx context.Context, batchID int32) ([]Sweep, error) {
	rows, err := q.db.QueryContext(ctx, getBatchSweeps, batchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sweep
	for rows.Next() {
		var i Sweep
		if err := rows.Scan(
			&i.ID,
			&i.SwapHash,
			&i.BatchID,
			&i.Outpoint,
			&i.Amt,
			&i.Completed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatchSweptAmount = `-- name: GetBatchSweptAmount :one
SELECT
        SUM(amt) AS total
FROM
        sweeps
WHERE
        batch_id = $1
AND
        completed = TRUE
`

func (q *Queries) GetBatchSweptAmount(ctx context.Context, batchID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBatchSweptAmount, batchID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getParentBatch = `-- name: GetParentBatch :one
SELECT
        sweep_batches.id, sweep_batches.confirmed, sweep_batches.batch_tx_id, sweep_batches.batch_pk_script, sweep_batches.last_rbf_height, sweep_batches.last_rbf_sat_per_kw, sweep_batches.max_timeout_distance, sweep_batches.cancelled
FROM
        sweep_batches
JOIN
        sweeps ON sweep_batches.id = sweeps.batch_id
WHERE
        sweeps.outpoint = $1
`

func (q *Queries) GetParentBatch(ctx context.Context, outpoint string) (SweepBatch, error) {
	row := q.db.QueryRowContext(ctx, getParentBatch, outpoint)
	var i SweepBatch
	err := row.Scan(
		&i.ID,
		&i.Confirmed,
		&i.BatchTxID,
		&i.BatchPkScript,
		&i.LastRbfHeight,
		&i.LastRbfSatPerKw,
		&i.MaxTimeoutDistance,
		&i.Cancelled,
	)
	return i, err
}

const getSweepStatus = `-- name: GetSweepStatus :one
SELECT
    COALESCE(s.completed, f.false_value) AS completed
FROM
    (SELECT false AS false_value) AS f
LEFT JOIN
    sweeps s ON s.outpoint = $1
`

func (q *Queries) GetSweepStatus(ctx context.Context, outpoint string) (bool, error) {
	row := q.db.QueryRowContext(ctx, getSweepStatus, outpoint)
	var completed bool
	err := row.Scan(&completed)
	return completed, err
}

const getUnconfirmedBatches = `-- name: GetUnconfirmedBatches :many
SELECT
        id, confirmed, batch_tx_id, batch_pk_script, last_rbf_height, last_rbf_sat_per_kw, max_timeout_distance, cancelled
FROM
        sweep_batches
WHERE
        confirmed = FALSE AND cancelled = FALSE
`

func (q *Queries) GetUnconfirmedBatches(ctx context.Context) ([]SweepBatch, error) {
	rows, err := q.db.QueryContext(ctx, getUnconfirmedBatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SweepBatch
	for rows.Next() {
		var i SweepBatch
		if err := rows.Scan(
			&i.ID,
			&i.Confirmed,
			&i.BatchTxID,
			&i.BatchPkScript,
			&i.LastRbfHeight,
			&i.LastRbfSatPerKw,
			&i.MaxTimeoutDistance,
			&i.Cancelled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBatch = `-- name: InsertBatch :one
INSERT INTO sweep_batches (
        confirmed,
        batch_tx_id,
        batch_pk_script,
        last_rbf_height,
        last_rbf_sat_per_kw,
        max_timeout_distance
) VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
) RETURNING id
`

type InsertBatchParams struct {
	Confirmed          bool
	BatchTxID          sql.NullString
	BatchPkScript      []byte
	LastRbfHeight      sql.NullInt32
	LastRbfSatPerKw    sql.NullInt32
	MaxTimeoutDistance int32
}

func (q *Queries) InsertBatch(ctx context.Context, arg InsertBatchParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertBatch,
		arg.Confirmed,
		arg.BatchTxID,
		arg.BatchPkScript,
		arg.LastRbfHeight,
		arg.LastRbfSatPerKw,
		arg.MaxTimeoutDistance,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateBatch = `-- name: UpdateBatch :exec
UPDATE sweep_batches SET
        confirmed = $2,
        batch_tx_id = $3,
        batch_pk_script = $4,
        last_rbf_height = $5,
        last_rbf_sat_per_kw = $6
WHERE id = $1
`

type UpdateBatchParams struct {
	ID              int32
	Confirmed       bool
	BatchTxID       sql.NullString
	BatchPkScript   []byte
	LastRbfHeight   sql.NullInt32
	LastRbfSatPerKw sql.NullInt32
}

func (q *Queries) UpdateBatch(ctx context.Context, arg UpdateBatchParams) error {
	_, err := q.db.ExecContext(ctx, updateBatch,
		arg.ID,
		arg.Confirmed,
		arg.BatchTxID,
		arg.BatchPkScript,
		arg.LastRbfHeight,
		arg.LastRbfSatPerKw,
	)
	return err
}

const upsertSweep = `-- name: UpsertSweep :exec
INSERT INTO sweeps (
        swap_hash,
        batch_id,
        outpoint,
        amt,
        completed
) VALUES (
        $1,
        $2,
        $3,
        $4,
        $5
) ON CONFLICT (outpoint) DO UPDATE SET
        batch_id = $2,
        completed = $5
`

type UpsertSweepParams struct {
	SwapHash  []byte
	BatchID   int32
	Outpoint  string
	Amt       int64
	Completed bool
}

func (q *Queries) UpsertSweep(ctx context.Context, arg UpsertSweepParams) error {
	_, err := q.db.ExecContext(ctx, upsertSweep,
		arg.SwapHash,
		arg.BatchID,
		arg.Outpoint,
		arg.Amt,
		arg.Completed,
	)
	return err
}
