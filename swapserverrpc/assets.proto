syntax = "proto3";

// We can't change this to swapserverrpc, it would be a breaking change because
// the package name is also contained in the HTTP URIs and old clients would
// call the wrong endpoints. Luckily with the go_package option we can have
// different golang and RPC package names to fix protobuf namespace conflicts.
package looprpc;

option go_package = "github.com/lightninglabs/loop/swapserverrpc";

service AssetsSwapServer {
    // QuoteAssetLoopOut requests a quote for an asset loop out swap from the
    // server.
    rpc QuoteAssetLoopOut (QuoteAssetLoopOutRequest)
        returns (QuoteAssetLoopOutResponse);

    // ListAvailableAssets returns the list of assets that the server supports.
    rpc ListAvailableAssets (ListAvailableAssetsRequest)
        returns (ListAvailableAssetsResponse);

    // RequestAssetLoopOut requests an asset loop out swap from the server.
    rpc RequestAssetLoopOut (RequestAssetLoopOutRequest)
        returns (RequestAssetLoopOutResponse);

    // PollAssetLoopOutProof requests the server to poll for the proof of the
    // asset loop out swap.
    rpc PollAssetLoopOutProof (PollAssetLoopOutProofRequest)
        returns (PollAssetLoopOutProofResponse);

    // RequestAssetBuy requests an asset buy swap from the server. This
    // requires an already confirmed asset output on chain.
    rpc RequestAssetBuy (RequestAssetBuyRequest)
        returns (RequestAssetBuyResponse);

    // RequestMusig2Sweep requests a musig2 sweep from the server.
    rpc RequestMusig2Sweep (RequestMusig2SweepRequest)
        returns (RequestMusig2SweepResponse);

    // NewAssetLoopIn requests a new asset loop in swap from the server.
    rpc NewAssetLoopIn (NewAssetLoopInRequest) returns (NewAssetLoopInResponse);

    // QuoteAssetLoopIn returns a quote for an initiated asset loopin swap.
    rpc QuoteAssetLoopIn (QuoteAssetLoopInRequest)
        returns (QuoteAssetLoopInResponse);

    // ExecuteAssetLoopIn executes an initiated asset loopin swap.
    rpc ExecuteAssetLoopIn (ExecuteAssetLoopInRequest)
        returns (ExecuteAssetLoopInResponse);

    rpc RevealOutputProof (RevealOutputProofRequest)
        returns (RevealOutputProofResponse);
}

message QuoteAssetLoopOutRequest {
    // amount is the amount of the asset to loop out.
    uint64 amount = 1;

    // asset is the asset to loop out.
    bytes asset = 2;
}

message QuoteAssetLoopOutResponse {
    // fixed_prepay_amt is the fixed prepay amount of the swap.
    uint64 fixed_prepay_amt = 1;

    // swap_fee_rate is the fee rate that is added to the swap invoice.
    double swap_fee_rate = 2;

    // current_sats_per_asset_unit is the sats per asset unit of the swap.
    uint64 current_sats_per_asset_unit = 3;
}

message ListAvailableAssetsRequest {
}

message ListAvailableAssetsResponse {
    // assets is the list of assets that the server supports.
    repeated AssetInfo assets = 1;
}

message AssetInfo {
    bytes asset_id = 1;
    uint64 current_sats_per_asset_unit = 2;
}

message RequestAssetLoopOutRequest {
    // amount is the amount of the asset to loop out.
    uint64 amount = 1;

    // receiver_key is the public key of the receiver.
    bytes receiver_key = 2;

    // requested_asset is the asset to loop out.
    bytes requested_asset = 3;
}

message RequestAssetLoopOutResponse {
    // swap_hash is the main identifier of the swap.
    bytes swap_hash = 1;

    // prepay_invoice is the invoice to pay to start the swap. On accepted
    // the server will publish the htlc output.
    string prepay_invoice = 2;

    // expiry is the expiry of the htlc output.
    int64 expiry = 3;

    // sender_pubkey is the public key of the sender.
    bytes sender_pubkey = 4;
}

message PollAssetLoopOutProofRequest {
    // swap_hash is the main identifier of the swap.
    bytes swap_hash = 1;
}

message PollAssetLoopOutProofResponse {
    // raw_proof_file is the raw proof file of the swap.
    bytes raw_proof_file = 1;
}

message RequestAssetBuyRequest {
    // swap_hash is the main identifier of the swap.
    bytes swap_hash = 1;
}

message RequestAssetBuyResponse {
    // swap_invoice is the invoice to pay to receive the preimage to claim the
    // asset.
    string swap_invoice = 1;
}

message RequestMusig2SweepRequest {
    // swap_hash is the main identifier of the swap.
    bytes swap_hash = 1;
    // digest is that the client wants the server to sign.
    bytes digest = 2;
    // receiver_nonce is the nonce of the receiver.
    bytes receiver_nonce = 3;
}

message RequestMusig2SweepResponse {
    // sender_nonce is the nonce of the sender.
    bytes sender_nonce = 1;
    // sender_sig is the signature of the sender.
    bytes sender_sig = 2;
}

// --- LOOP IN ---
message NewAssetLoopInRequest {
    bytes asset_id = 1;

    uint64 amount = 2;

    bytes sender_pubkey = 3;
}

message NewAssetLoopInResponse {
    bytes swap_hash = 1;

    bytes receiver_pubkey = 2;
}

message QuoteAssetLoopInRequest {
    bytes swap_hash = 1;
}

message QuoteAssetLoopInResponse {
    // TODO: we may want to use a more precise price, eg. sats per 100 asset
    // units or similar.
    uint64 sats_per_asset_unit = 1;

    uint64 prepay_amt = 2;

    // Expiry is the unix timestamp of the expiry of the quote.
    int64 expiry = 3;
}

message ExecuteAssetLoopInRequest {
    bytes swap_hash = 1;

    string swap_invoice = 3;
}

message ExecuteAssetLoopInResponse {
    string prepay_invoice = 1;
}

message RevealOutputProofRequest {
    bytes swap_hash = 1;

    bytes raw_proof_file = 2;
}

message RevealOutputProofResponse {
    bytes preimage = 1;
}
